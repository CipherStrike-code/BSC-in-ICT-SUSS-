## CPU Structure
CPU must:
- Fetch Instruction
- Decode Instruction
- Fetch Data
- Process Data
- Store Data

## CPU Internal Structure
<p align="center">
  <img width="560" height="464" alt="image" src="https://github.com/user-attachments/assets/81668f1b-008c-45bc-b8c1-1967491a5628" /><br>
  Figure 3.1
</p>

## User Visible Registers
- General Purpose Registers
  - Assigned to a variety of functions by the programmer
  - Can be used for data (as an accumulator) or addressing functions
- Data Registers
  - Used only to hold data
  - Cannot be employed in the calculation of an operand address
- Address Registers
  - Used to hold Address or employed in the calculation of an operand address
  - Used as a Stack Pointer
- Condition Codes Registers
  - Contains flags or bits set by the processor hardware as the result of operation
  - E.g. Result of last operation is 0

## Von Neumann Computer Architecture - Control & Status Registers
The Von Neumann Computer Architecture is widely used in general-purpose computing.
Registers that are used are:
1. Program Counter (PC)
  - Contains the address of an instruction to be fetched
  - Automatically points to the next instruction after the current instruction is fetched
2. Instruction Register (IR)
  - Contains the most recently fetched instruction
3. Memory Address Register (MAR)
  - Contains the address of a location in memory
4. Memory Buffer Register (MBR)
  - Contains a word of data to be written to memory or the word most recently read
5. Program Status Word (PSW)
  - Contains a set of bits that includes condition codes
  - Sign of last result, Zero, Carry-Over, Equal, Overflow, Interrupt, Supervisor (indicates whether processor is executing in supervisor or user mode.

## Assembly Language, Motorola MC 68000 Processor, EASy68k and M114
- An assembly language is a low-level programming language, and is machine dependent.
  - Machine Dependent means it runs on a specific computer.
  - Machine Independent means it runs on multiple different type of hardware.
  - For example, machine code for x86 architecture cannot be used for Motorola MC68000 architecture.
- Each instruction of the assembly language corresponds directly to a CPU operation.
- We will touch on assembly language programming for the Motorola MC68000 processor.
- EASy68k is the Editor/Assembler/Simulator for the Motorola MC68000 microprocessor.
- EASy68k allows us to edit, assembl and run 68000 programs on a Windows PC.

## Motorola MC68000 CPU Registers (1)
<p align ="center">
  <img width="255" height="348" alt="image" src="https://github.com/user-attachments/assets/f376d297-f4a8-48cf-a609-0c2ae8688603" /><br>
  <img width="255" height="112" alt="image" src="https://github.com/user-attachments/assets/05dd1e08-85a8-4831-a755-3f2db5728a87" /><br>
  Figure 3.2
</p>




## Data Registers
- D0 to D7, Data Registers - 32-bit and can be treated as 8,16 or 32 bits.
- Instruction with a .B indicates Data Register is handling 8 bits or 1 byte.
  - I.e. bit 0 to bit 7
  - E.g. MOVE.B D0, D1
- Instruction with .W indicates Data register is handling 16 bits or 1 word
  - I.e. bit 0 to bit 15
  - E.g. MOVE.W D0, D1
- Instruction with .L indicates Data register is handling 32 bits or 1 long word
  - I.e. bit 0 to bit 31
  - E.g. MOVE.L D0, D1

## Address Registers
- A0 to A6, Address Registers – 32-bit
- A7, Stack Pointer – 32-bit
- PC, Program Counter – 32-bit
- SR, Status Register – 16-bit
  - There are 5 status flags
  - For this module, we will focus on 2 status flags
  - Z flag or Zero flag
    - Is set (Z=1) when an arithmetic or logical operation resulted in destination operand equal to zero
  - N flag or Negative flag
    - Is set (N=1) when an arithmetic or logical operation resulted in destination operand to be negative

## Motorola MC68000 Memory Organisation 
- All numbers in MC68000 assembly language are in hexadecimal
  - `$` prefix denotes hexadecimal
- Address bus is 24-bit wide - can address $2^{24}$ memory locations
- Range $000 000 to $FFF FFF. A space is added after every 3 hexadecimal digits to improve readability.
- Each memory address or location holds a byte of storage.
- Can be organised as
  - 8 bit or byte
  - 16 bit or word or
  - 32 bit or long word
- Words and long words must be aligned on even address
- MC68000 uses big endian byte ordering - multi-byte data (like words and long words) is stored with the most significant byte at the lowest memory address.

<p align ="center">
  <img width="652" height="475" alt="image" src="https://github.com/user-attachments/assets/bfcd5a2f-16e5-4f3c-b088-59bf98d26de9" />
</p>

## Example
If a 32-bit long word $12345678 is stored at address $001000. This is how it is stored.
<p align="center">
  <img width="1156" height="542" alt="image" src="https://github.com/user-attachments/assets/04284106-f99f-41dc-a7c8-b5b1d678497c" />
</p>

## M114 CPU Instruction Set
<p align="center">
  <img width="825" height="687" alt="image" src="https://github.com/user-attachments/assets/97bc9d34-8c5a-4783-a6ce-e3ea8afdebc1" /><br>
  <img width="825" height="547" alt="image" src="https://github.com/user-attachments/assets/013b3fe1-5988-449d-a7c1-1d7c89d109fb" /><br>
  <img width="549" height="273" alt="image" src="https://github.com/user-attachments/assets/2c9fa3ca-4c04-4439-b8e4-adba5d56e946" />
</p>

- Each instruction consists of 2 parts
  - Operation Code (Op code)
  - Operand Specification
  - E.g. MOVE D0, D1 (Move D0 to D1)
- Op code: MOVE
- Operand Specification
  - Source Operand E.g. D0
  - Destination and Result Operand E.g. D1
- You are expected to know and use the M114 instruction set for TMA and the exam.

## Addressing Modes
- Data to be operated on can be specified in different ways in an instruction
  - In the data register
  - In the instruction itself
  - In memory, etc
- The way an instruction operand specifies the data is known as its addressing modes

## Common Motorola MC68000 Addressing Modes
- Immediate Addressing (source operand is a Data)
  - `#` prefix denotes immediate
  - E.g. MOVE.L #$12345678, D0 (Data $12345678 is loaded to register D0)
- Absolute Addressing (source operand is an Address) Direct
  - E.g. MOVE.L $1234, D0 (Content at address $1234 is loaded to register D0)
  - $1234 is the address of the operand
- Register Direct Addressing
  - Source and Destination operands are the contents of the registers
  - E.g. MOVE.L D0, D1 (Register D0 is the source, D1 is the destination)
- Register Indirect Addressing
  - Location of operand is in an address register
  - E.g. MOVE.B (A0), D0 (Content at address given in A0 is loaded to register D0)
  - Register A0 contains the address of the operand
<p align="center">
  <img width="1131" height="316" alt="image" src="https://github.com/user-attachments/assets/e1931862-f131-4c33-8fc2-c85c257e7d66" />
</p>
- Register Indirect with Post-Increment Addressing
  - Address register content is increment by 1 for .B, 2 for .W or 4 for .L after the operation
  - E.g. MOVE.W (A0)+, D0 (Content at address given in A0 is loaded to register D0. After the operation, the content of A0 is incremented by 2.)
<p align="center">
  <img width="689" height="225" alt="image" src="https://github.com/user-attachments/assets/d08cbd4f-be2d-497e-895e-66386d5528ac" />
</p>
- Register Indirect with Pre-decrement Addressing
  - Address register content is decrement by 1 for .B, 2 for .W or 4 for .L before the operation
  - E.g. MOVE.L -(A0), D0 (Content at address given in A0 is decremented by 4. Content at new address given in A0 is loaded to register D0.)
<p align="center">
  <img width="793" height="270" alt="image" src="https://github.com/user-attachments/assets/93ca8e4f-ee05-47ee-bac0-93eb0ba0d6ff" />
</p>
Important Notes:
- Normal processors have more addressing modes, but for this course, we shall limit it to the above.

## Transfer of Control - Conditional
- Conditional Branch
  – E.g. BEQ <label> - branch if equal to zero (result of previous operation)
    - Note: <label> is a symbolic name used to represent a memory address
    - If Z flag is set (Z=1), PC = address at <label> after this instruction, i.e. branch to address indicated by <label>
    - If Z flag is not set (Z=0), no branching, program will execute the next instruction given in PC 

  - E.g. BNE <label> - branch if not equal to zero (result of previous operation)
    - If Z flag is not set (Z=0), PC = address at <label> after this instruction, i.e. branch to address indicated by <label>
    - If Z flag is set (Z=1), no branching, program will execute the next instruction given in PC
  - E.g. BPL <label> - branch if plus (zero or positive) (result of previous operation)
    - If N flag is not set (N=0), PC = address at <label> after this instruction, i.e. branch to address indicated by <label>
  - E.g. BMI <label> - branch if minus (result of previous operation)
    - If N flag is set (N=1), PC = address at <label> after this instruction, i.e. branch to address indicated by <label>

## Transfer of Control - Unconditional
- Unconditional Branch and Jump
  - E.g. BRA <label> or JMP <label> - branch or jump to <label>
    - PC = address at <label> after this instruction
- Difference between BRA and JMP?
  - In BRA, <label> is calculated relative to current PC value (relative addressing)
  - For JMP, <label> is an absolute value (absolute addressing)
- Note: SUB D0, D1 (D0 is the source, D1 is the destination)
  - Implies <dest> - <source>, result store in <dest>

## Branch Subroutine and Use of Stack
**Branch Subroutine**
- What is a Subroutine?
  - A block of codes that is called by a main program to do a task and a return is made to the calling point
- What is the advantage of a subroutine?
  - Reduce repetition of a common block of code
  - Break a program into smaller and manageable parts
  - Save memory space
- Call subroutine using JSR or BSR and return using RTS
  - JSR <label> or BSR <label>
  - Call the subroutine at address <label>
  - RTS will return execution to the calling point

**Use of Stack**
-  What is a Stack?
  - Some memory used to store return address of subroutine
- A7 is an address register that is used as a stack pointer




















































































































