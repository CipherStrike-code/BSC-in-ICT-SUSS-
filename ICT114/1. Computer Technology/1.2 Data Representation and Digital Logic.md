## Objectives:
- Convert a number from one number system to another
- Represent integer in binary using unsigned magnitude, sign-magnitude and two's complement
- Represent real numbers in binary
- Perform simple arithmetic operations using various binary representations
- Perform logic operation using binary numbers.

## Computer Data
Data are represented in binary digits/bits (0 and 1). Basic data types are:
- Integer
- Real Number
- Character

## Decimal-Binary Hexadecimal Table
<p align="center">
  <img width="448" height="213" alt="wmremove-transformed" src="https://github.com/user-attachments/assets/1b687d1b-fc7d-4b9b-a01c-0c861cfa9013" />
</p>

# Conversion
We will now learn to convert from one number system to another. This is because humans typically understand number in decimal form (Base 10) which computers operate in binary form (Base 2). Octal (Base 8) and Hexadecimal (Base 16) make binary easier to read.

## Binary (Base 2) to Decimal (Base 10)
The Most Significant bit is the one on the most left while the Least Significant Bit is the one on hte most right. <br>

**Steps:**
1. Write down the positions numbers for each binary digit. Always remember to start counting from right most with the first starting from 0.
2. Multiply the respective binary digit with the $2^{(Position Number)}$.
3. Add up all the results together.
   

**Example:** <br>
10110 = 1* $2^{4}$ + 0 * $2^{3}$ + 1 * $2^{2}$ + 1 * $2^{1}$ + 0 * $2^{0}$ <br>
10110 = 16 + 0 + 4 + 2 + 0 <br>
10110 = 22

## Decimal (Base 10) to Binary (Base 2)
**Method 1**
Undestanding the different positional values and adding them up to form the number.
<p align="center">
  <img width="643" height="197" alt="image" src="https://github.com/user-attachments/assets/ca3ca990-cf03-4ad5-8f9c-5fecdc04baca" />
</p>

**Method 2**
1. Divide by number 2 and obtain the remainder. Write down the remainder.
2. Repeat step 1 but using the quotient from step 1. If the dividend is smaller than the divisor, the dividend will be the next remainder.
3. Read the remainders from bottom up.

## Decimal (Base 10) to Hexadecimal (Base 16)
**Steps:**
1. Divide by number 16 and obtain the remainder. Write down the remainder. If the remainder is between 10-15, use A - F.
2. Repeat step 1 but using the quotient from step 1. If the dividend is smaller than the divisor, the dividend will be the next remainder.
3. Read the remainders from bottom up.

**Example: 254** <br>
First division: 254/16 = Quotient 15 Remainder 14 (Hex digit E) <br>
Second division: 15/16 which is not possible so the remainder is 15 (Hex digit F) <br>
Thus if we read from bottom up is **FE**. <br>

## Hexadecimal (Base 16) to Decimal (Base 10) 
**Steps:**
1. Write down the positions numbers for each binary digit. Always remember to start counting from right most with the first starting from 0.
2. Multiply the respective binary digit with the $16^{(Position Number)}$.
3. Add up all the results together.

Example is same as binary to decimal except is 16 instead of 2.

## Binary (Base 2) to Hexadecimal (Base 16)
**Steps:**
1. Split the binary into groups of 4 bits, strating from the right (LSB). If there is 1 group with 3 only, add 0 in front to make it groups of 4.
2. Convert every group to its decimal equivalent
3. Convert from decimal to hexadecimal from left to right. No division is required. Decimal 0-9 is same as hexadecimal. Decimal 10-15 is A-F in hexadecimal. 

**Example: 0010 0100 1000**
The first group which is the left most is 2 in decimal.
The second group which is in the middle is 4 in decimal.
The last group which is the most right is 8 in decimal.
Thus is 248 in hexadecimal.

## Hexadecimal (Base 16) to Binary (Base 2)
**Steps:**
1. Split the hexadecimal digit individually.
2. Convert from Decimal to Binary.
   - Hex 0–9 → binary 0000–1001
   - Hex A–F → binary 1010–1111
4. Each group is of 4 binary bits which is 1 hexadecimal or decimal digit.

# Number Systems
There are three types of number system. They are:
1. Unsigned Magnitude
2. Sign Magnitude
3. Two's Complement

## Unsigned Magnitude
- Represent only zero and positive values.
- Positive numbers stored in binary.
- E.g. 41 (Base 10) = 0010 10012 (Base 2)
- Range of unsigned numbers: 0 to $2^{n}$ - 1 <br>

Example: <br>
4-bit Number: Ranges 0 to 15. <br>
8-bit Number: Ranges 0 to 255. <br>
16-bit Number: Ranges 0 to 65,535. <br>

Use Case of Unsigned Binary Representation:
- Bytes in RAM. A 32-bit system can access 4GB of memory (0 to 4,294,967,295).
- RGB color values (0-255) use 8-bit unsigned numbers per channel. Image dimensions dimensions and pixel counts also rely on unsigned ranges.
- Microprocessors use unsigned values for status flags and control signals where only positive states exist

## Signed Magnitude
- Represents both positive and negative values by allocating one bit (usually the MSB) as the sign indicator.
- 0 represent positive while 1 represent negative.
- Uses the leftmost bit as a sign flag while remaining bits are used to store absolute value. 
- Range of Sign-Magnitude (-2n-1 - 1 to  2n-1 - 1)<br>
Example:
1. +18 (Base 10) = 0001 0010 (Base 2)
2. -18 (Base 10) = 1001 0010 (Base 2)

## Problems with using Signed Magnitude
- In mathematics, we typically use plus and minus in front of the numbers to represent negative or positive. However, we are unable to use that in binary as computers dont follow that convention. 
- We will need to limit the numbers of bits for the magnitude which is not ideal due to impracticality of representing larger positive/negative numbers.

## Two's Complement
- Left most bit is sign bit (Similar to signed bit)
- - 0 represent positive while 1 represent negative. (Similar to signed bit)
- For positive numbers, the representation is the same as unsigned binary.
- For negative numbers, it takes the binary of the absolute value, invert all the bits, and add 1 to the right most bit. <br>

Example: 8 bits complement <br>
+8 (Base 10) = 0000 1000 (Base 2) <br>
-8 (Base 10) = 1111 1000 (Base 2) <br>

It is important to indicate the full number of bits for any fixed bit-width. <br>

**Limitations** <br>
1. 2's Complement has a limited range. It uses an n-bit system, and represents values from $-2^{(n-1)}$ to $2^{(n-1)}$ - 1, restricting the number of values that can be processed. 

**Benefits:** <br>
1. It is easy to represent a negative number.
2. The range for positive numbers is smaller than negative numbers. Negative values range from $-2^{(n-1)}$ to -1, while positive values range from 0 to $2^{(n-1)}$ - 1, creating an imbalance.

## Range of 2's Complement Numbers
- N bit range: $-2^{N-1}$ to $+2^{N-1}$ - 1

## Conversion between lengths
This is important to know if you need to convert the lengths of the representation or bit width. <br>

For negative number: Add 1's in front to fill up the bits. <br>
For positive numer: Add 0's in front to fill up the bits. <br>

#Arithmethic and Logic Operations
The computer can do 2 types of operations: <br>
1. Arithmetic Operations (Addition, Subtraction, Multiplication and Division) <br>
2. Logic Operations (OR, AND, XOR, NOT) <br>

## Addition and Subtraction 


## Real Numbers
- Real Numbers in computer terms consist of fixed point numbers & floating point numbers.

## Fixed Point Numbers
- The Binary Point is always fixed in one spot.
- Has small range of values depending on the fixed format.
- Precision stays the same for all values.
- Just integer and fraction bits is used for storage.
- Faster and simpler calculations.
- Used when range is known and fixed.

## Floating-Point Numbers
- Position stored separately via exponent.
- Huge range of values.
- Precision decreases for large numbers.
- Sign bit + exponent + mantissa is used for storage.
- Slower, more complex hardware logic.
- Used when number vary widely in size such as graphic.

## Logic Operations
<img width="1303" height="949" alt="image" src="https://github.com/user-attachments/assets/b897c479-a961-4f10-96d5-8adff39e198c" />

























